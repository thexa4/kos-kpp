module static-semantics

imports

  signatures/-
  

signature

  sorts
    Void

  namespaces
    Module
    Class
    Variable
    Method
    Field
    Block
    Identifier
  
  name resolution
    labels P
  
  constructors
    Number :  Type
    String : Type
    Class : Type
    Object : Class -> Type
    Dynamic : Type
    Func : list(Type) * Type -> Type
    Coerce : Type -> Type
    Ref : Type * Declaration -> Type

  constraint generator
  
    [[ Expr ^ (scope) : Type ]]

rules

  init ^ (topScope) :=
    Number() <! Dynamic(),
    new topScope.

  [[ ModernFile(File(usings, classes)) ^ (topScope) ]] := 
    Map1 [[ classes ^ (topScope) ]].
    
  [[ LegacyFile(_) ^ (topScope) ]] := false | note "No support for legacy files".

  [[ Class(classname, definitions) ^ (topScope) ]] :=
    distinct/name D(topScope)/Identifier | note "Duplicate identifier" @NAMES,
  	Identifier { classname } <- topScope,
  	new classScope,
  	Identifier { classname } ===> classScope,
  	Identifier { classname } : Type(Identifier { classname }),
  	Identifier { "alloc" } <- classScope,
  	Identifier { "alloc" } : Func(Object(classname), []),
  	Func(Object(classname), []) <! Dynamic(),
    classScope ---> topScope,
    new instanceScope,
    instanceScope ---> classScope,
    Identifier { "this" } <- instanceScope,
    Identifier { "this" } : Object(classname),
    Object(classname) <! Dynamic(),
    Identifier { "this" } ===> instanceScope,
    Map2 [[ definitions ^ (instanceScope, classScope) ]].
  
  [[ Method(methodType, methodName, parameters, methodInstructions) ^ (instanceScope, classScope) ]] :=
    distinct/name D(instanceScope)/Identifier | note "Duplicate identifier" @NAMES,
    Identifier { methodName } <- instanceScope,
    Identifier { methodName } : Func(paramTypes, methodType),
    Func(paramTypes, methodType) <! Dynamic(),
    StripParameters[[ parameters ^ () : paramTypes ]],
    Map1 [[ methodInstructions ^ (instanceScope) ]],
    new methodScope,
    methodScope ---> instanceScope.
  
  StripParameters [[ [] ^ () : [] ]].
  StripParameters [[ [elem | rest] ^ () : [eType | restTypes] ]] :=
  	StripParameters [[ elem ^ () : eType ]],
  	StripParameters [[ rest ^ () : restTypes ]].

  StripParameters [[ Parameter(type, _) ^ () : type ]].
    
  [[ Field(typeLiteral, fieldName, fieldExpr) ^ (instanceScope, classScope) ]] :=
    distinct/name D(classScope)/Identifier | note "Duplicate identifier" @NAMES,
    Identifier { fieldName } <- instanceScope,
    fieldScope -P-> instanceScope,
    Identifier { fieldName } : Ref(fieldType),
    Ref(fieldType) <! fieldType,
    [[ fieldExpr ^ (classScope) : exprType ]],
    //[[ exprType ^ () : fieldtype ]],
    exprType <? fieldType,
    //coerce == Coerce(exprType),
    //[[ coerce ^ () : Coerce(fieldType) ]],
    new fieldScope,
    typeLookup [[ typeLiteral ^ () : fieldType ]],
    fieldScope ---> instanceScope.
  
  [[ Declaration(typeLiteral, varName) ^ (methodScope) ]] :=
    distinct/name D(methodScope)/Variable | note "Duplicate identifier - foo42" @NAMES,
    Identifier { varName } <- methodScope,
    Identifier { varName } : Ref(varType),
    Ref(varType) <! varType,
    Identifier { varName } genOf varType,
    typeLookup [[ typeLiteral ^ () : varType ]],
    new varScope.
  
  [[ Assignment(victim, valueExpr) ^ (methodScope) ]] :=
    [[ victim ^ (methodScope) : victimType ]],
    victimType == Ref(refType) | note "Not a writable reference",
    [[ valueExpr ^ (methodScope) : valueType ]],
    valueType <? refType.
  
  [[ DeclarationAssigned(typeLiteral, varName, valueExpr) ^ (methodScope) ]] :=
    distinct/name D(methodScope)/Variable | note "Duplicate identifier" @NAMES,
    Identifier { varName } <- methodScope,
    Identifier { varName } : Ref(varType),
    [[ valueExpr ^ (methodScope) : valType ]],
    typeLookup [[ typeLiteral ^ () : varType ]],
    valType <? varType,
    new varScope.
  
  [[ Identifier(varName) ^ (scope) : t ]] :=
  	Identifier { varName } -> scope,
  	Identifier { varName } |-> declaration,
  	declaration : t.
  
  [[ Accessor(victim, _, propertyName) ^ (methodScope) : declaration ]] :=
    [[ victim ^ (methodScope) : reference ]],
    new accessorScope,
    reference ?===> classScope,
    accessorScope ---> classScope,
    Identifier { propertyName } -> accessorScope,
    Identifier { propertyName } |-> declaration.
    
  [[ ExprInstruction(a) ^ (scope) ]] :=
  	[[ a ^ (scope) : _ ]].
   
  [[ Using(_) ^ (topScope) ]] := false.
  
  [[ LegacyBlock(_) ^ (_) ]].
  
  [[ NumberLiteral(_) ^ (_) : Number() ]].
  [[ StringLiteral(_) ^ (_) : String() ]].
  
  typeLookup [[DynamicT() ^ () : Dynamic() ]].
  typeLookup [[NumberT() ^ () : Number() ]].
rules // instructions

  