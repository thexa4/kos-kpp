module kscript

imports
  signatures/Common-sig
  signatures/KOS-sig
  signatures/KPP2-sig
  nabl2/api
  nabl2/-
  
  desugar
  pp

strategies
  transform-kscript(|analysis) = innermost(legacy(|analysis))
  
  fix-quotes = innermost(add-quotes)
  
rules
  
  //expand-accessors(|analysis): Accessor(a, b, c) -> a
  //	with
  //	  params := <nabl2-get-ast-params
  
  
    //with
    //  analysis := <nabl2-get-ast-analysis; debug> any
    //  ; termParams := <nabl2-get-ast-type(|analysis)>
  
  add-quotes: AddQuotes(inner) -> <conc-strings>("\"", inner, "\"")
  
  //strip-types: Cast(_, a) -> a
  strip-legacy: Legacy(a) -> a
  
  legacy(|analysis): NumberLiteral(a)					-> Legacy(KNumber(a))
  legacy(|analysis): Div(Legacy(a), Legacy(b))	-> Legacy(KDiv(a, b))
  
  legacy(|analysis): Declaration(_, name) 			-> LegacyBlock([KDeclareIdentifierUnscoped("declare", name, KDefaultPreset("to", KNumber("0")), ".")])
  legacy(|analysis): Assignment(victim, Legacy(value)) 	-> LegacyBlock([KSet(<location-decode(|analysis)>victim, value, ".")])
  //  with
  //    termParams := <nabl2-get-ast-type(|analysis)> victim
  
  location-decode(|analysis): input@Identifier(content) -> fixed
    with
      Ref(_, declaration) := <nabl2-get-ast-type(|analysis)> input
      ; location := <nabl2-get-property(|analysis, "location")> declaration
      ; fixed := <fix-quotes>(location)
  location-decode(|analysis): rest -> rest
  
  //legacy(|analysis): input@Accessor(any, _, _) -> KIdentifier(any)
  
  
  legacy(|analysis): ExprInstruction(Legacy(expr)) -> LegacyBlock(KExpression(expr))
  legacy(|analysis): Add(Legacy(a), Legacy(b)) -> Legacy(KAdd(a, b))
  
  //legacy(|analysis): Identifier(name) -> Legacy(KIdentifier(analysis)) // Todo, use type lookup
  //  with
  //    termParams := <nabl2-get-ast-type(|analysis)> Identifier(name)
  
  legacy(|analysis): DesugaredClass(name, fields, methods) -> KDeclareIdentifierScoped("declare", "global", <conc-strings>("class_", name), KDefaultPreset("to",
      KFunctionCall(KIdentifier("lexicon"), <flatten-list> ["\"new\"", KAnonymousFunction([
        KSet(KIdentifier("result"), KFunctionCall(KIdentifier("lexicon"), []), "."),
      	KBlock(<flatten-list> [
      		<map(initialize-class(|analysis))> fields,
      		KSet(KArrayIndex(KIdentifier("result"), KString("\"prototype\"")), KIdentifier(<conc-strings>("class_", name)), ".")
      	]),
      	KReturn(Some(KIdentifier("result")), ".")
      ]), <map(define-methods)> methods])
    ), ".")
    
  initialize-class(|analysis): Field(_, name, value) -> KSet(KArrayIndex(KIdentifier("result"), KString(<conc-strings>("\"", name, "\""))), <strip-legacy; innermost(legacy(|analysis))> value, ".")
  
  define-methods: Method(_, name, params, instructions) -> [KString(<conc-strings>("\"", name, "\"")), KAnonymousFunction(<flatten-list>[params, [<flatten-legacy-blocks>instructions]])]
    where not( <?[LegacyBlock(_)]> instructions)
  
  legacy(|analysis): Parameter(_, name) -> KDeclareParameter(None(), [KDefaultDefinition(name, None())], ".")
  
  flatten-legacy-blocks: [] -> []
  flatten-legacy-blocks: [LegacyBlock(head)|tail] -> [head|<flatten-legacy-blocks>tail]
  flatten-legacy-blocks: [head|tail] -> [head|<flatten-legacy-blocks>tail]
  	
  legacy(|analysis): ModernFile(File(usings, legacyInstructions)) -> LegacyFile(<flatten-list>legacyInstructions)